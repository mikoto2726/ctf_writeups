## safe prime
問題文

Using a [safe prime](https://en.wikipedia.org/wiki/Safe_and_Sophie_Germain_primes) makes RSA secure, doesn't it?

tar.gzファイルがあるのでダウンロードします。
```
wget https://score.beginners.seccon.jp/api/download?key=beginners2024%2FSafe_Prime.tar.gz
```
zipファイルを解凍します。
```
unzip download\?key=beginners2024%2FSafe_Prime.tar.gz 
```
Safe Primeというフォルダが出てきたのでこのディレクトリに移動します。
```
cd Safe\ Prime/  
```
lsコマンドでフォルダの中身を確認します。
```
ls
```
chall.pyとoutput.txtの二つのファイルがありました。
catコマンドで中身を確認します。
```
cat chall.py
```
↓出力結果
```
import os
from Crypto.Util.number import getPrime, isPrime

FLAG = os.getenv("FLAG", "ctf4b{*** REDACTED ***}").encode()
m = int.from_bytes(FLAG, 'big')

while True:
    p = getPrime(512)
    q = 2 * p + 1
    if isPrime(q):
        break


n = p * q
e = 65537
c = pow(m, e, n)

print(f"{n = }")
print(f"{c = }")
```

```
cat output.txt
```
↓出力結果
```
n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291
c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861
```
以下試行錯誤した軌跡
私は問題文にあるwikipediaをよみ、Googleでsafe primeと検索し、こちらの[wikipedia](https://ja.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E7%B4%A0%E6%95%B0)を読みました。
まずpとqを見つけて以下の方法で解こうとしました。
```math
\displaylines{ 
\begin{align}
φ & = (p-1)(q-1)\\
d & = e^{-1}(mod\;φ)\\
m & = c^d(mod \;n)\\
\end{align}
}
```
6n-1を使う方法を考えたり、メルセンヌ素数を使う方法を考えましたが、解けませんでした。
このままnをpで割れるかどうかやっても時間がかかりすぎるので探索範囲を
```math
\sqrt{\frac{n}{2}}から\sqrt{n}に絞りました。
```

以下が解けたコードです。
solve3.py
```
from math import isqrt
from Crypto.Util.number import long_to_bytes, inverse

# 与えられたnとc
n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291
c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861

# pとqを見つける
def find_p(n):
    for p in range(isqrt(n//2), isqrt(n) + 1):
        if n % p == 0:
            q = n // p
            if q == 2 * p + 1:
                return p
    return None

p = find_p(n)
if p is None:
    raise ValueError("Failed to find correct p and q")

q = 2 * p + 1

# pとqが正しいか確認
if p * q != n:
    raise ValueError("Failed to find correct p and q")

# 秘密鍵dを計算
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

# cを復号してFLAGを取得
m = pow(c, d, n)
flag = long_to_bytes(m).decode()

print("FLAG:", flag)
```
以下は想定解です。

```math
\begin{align}
n &= p*q \\
  &= p(2p+1) \\
  &= 2*p^2 + p
\end{align}
```
これを解くことでpとqを導く事が出来ます。
```math
\displaylines{
2*p^2 + p - n = 0 \\
p = \frac{-1 + \sqrt{8*n+1}}{4}\
}
```

pとqが求まったのであとは上の式の通りに解けます。

solve4.py
```
import math
from Crypto.Util.number import long_to_bytes
n = 292927367433510948901751902057717800692038691293351366163009654796102787183601223853665784238601655926920628800436003079044921928983307813012149143680956641439800408783429996002829316421340550469318295239640149707659994033143360850517185860496309968947622345912323183329662031340775767654881876683235701491291

c = 40791470236110804733312817275921324892019927976655404478966109115157033048751614414177683787333122984170869148886461684367352872341935843163852393126653174874958667177632653833127408726094823976937236033974500273341920433616691535827765625224845089258529412235827313525710616060854484132337663369013424587861

e = 65537

p = (math.isqrt(8 * n + 1) - 1) // 4
q = 2 * p + 1
d = pow(65537, -1, (p-1)*(q-1))
m = pow(c, d, n)
print(long_to_bytes(m))
```

上記の一元二次方程式を解く方法にsageを使うものや、二分探索を使って解いている人もいました。











