# packed

### ChatGPTとの会話で行った解析をまとめます。

---

## **全体の目的**
- `a.out` バイナリの解析を行い、正しい入力を見つけてFLAGを取得する。

---

## **解析の進行状況**

### **1. 初期状態の確認**
- **`a.out`の情報**:
  - `file` コマンドで確認：`UPX`でパックされたバイナリであると判明。
  - `strings`コマンドや`binwalk`で調査。

- **対処**:
  - `upx -d` コマンドで解凍し、通常のバイナリ形式に戻す。
  - 解凍後、`file`コマンドで「not stripped」（シンボルテーブルが一部残っている）ことを確認。

---

### **2. GDBを使った動的解析**
#### **ステップ**
1. **エントリポイントを追跡**:
   - `_start`からステップ実行し、`main`関数に到達。
   - レジスタやメモリの値を確認。

2. **重要な関数とアドレスの確認**:
   - `main`関数で出力(`write`)と入力(`read`)が処理されている箇所を特定。
   - `FLAG:`がアドレス`0x498004`に格納されていることを確認。

3. **条件分岐や入力判定の追跡**:
   - 条件分岐や比較命令（例: `cmp`, `jne`）を確認するためにステップ実行。
   - 入力データがどのように処理されているか追跡。

---

### **3. Ghidraを使った静的解析**
#### **重要な情報**
- **文字列参照の解析**:
  - `0x498004` に `FLAG:` の文字列が格納されている。
  - 他に「Wrong.」やエラーメッセージが見つかる。

- **関数リストの確認**:
  - `main`関数と、それが呼び出すサブルーチンを特定。

- **条件分岐の解析**:
  - FLAG生成のロジックが条件分岐に基づく可能性が高い。
  - 条件を満たす入力を逆算する必要がある。

---

### **4. 判明したロジックの一部**
- `main`関数で以下の流れが確認された：
  1. **`write`でFLAGのヘッダを出力**:
     - アドレス`0x498004`から`"FLAG: "`を出力。
  2. **`read`でユーザー入力を取得**:
     - 入力はスタック上のメモリ（例: `-0x90(%rbp)`）に格納。
  3. **入力の判定**:
     - 比較や計算による条件分岐があり、正しい入力を満たすと完全なFLAGが生成される。

---

### **次の解析手順**
1. **条件分岐の詳細を確認**:
   - `cmp`や`je`/`jne`などを追跡し、正しい入力条件を特定。
   - GhidraやGDBで比較対象や条件分岐のロジックを解析。

2. **入力とFLAG生成の追跡**:
   - `read`で取得された入力がどう処理されるか追跡。
   - メモリやレジスタを監視し、FLAGが生成される条件を逆算。

3. **FLAG取得の試行**:
   - 条件を満たす入力を導出し、プログラムを実行してFLAGを取得。

---

### **まとめ**
- 現在、`write`と`read`の呼び出しと入力処理の追跡まで進んでいます。
- 次は条件分岐と入力判定ロジックを特定し、FLAGを生成する条件を逆算する段階です。
- 動的解析と静的解析を組み合わせて、FLAG生成ロジックの全容を明らかにします。

---

